> https://juejin.cn/post/7124955707723481125
>
> - 之前的一部分理解是从使用层面上（React 灵活的 JSX 和 Vue 智能依赖收集）以及风格等
> - 两个框架核心的逻辑服用方法 Hook 的不同
> - 优化方向不同 （Vue 响应式优化和 diff 优化，React 的 Fiber 架构、并发模式、RSC）
> - 其他：React 函数式编程，V2 和 React 区别大，V3 趋近相同，都是声明式/Hook 等
> - 再聊一点 React 地层概念

## Hook 的不同

相同的是都是用于逻辑复用

Hook 在 React 函数组件中用于添加状态和副作用。它们可以使函数组件像类组件一样具有状态和副作用，但是在使用它们时，需要注意一些限制。

首先，Hook 必须在函数组件的顶层调用，这意味着它们不能在循环、条件判断或嵌套函数中使用，因为 React 需要确保每次渲染时，Hook 的顺序不会改变。由于 React 可能会多次调用组件函数，因此使用 Hook 的顺序必须始终保持一致，以确保数据和函数之间的关系正确。

当 React 需要重新渲染组件时，它会调用函数组件，计算出组件的新 Props 和 State，然后重新运行组件函数来生成组件的 UI 元素，最终展现在界面上。如果 Hook 的顺序在不同的渲染过程中发生了变化，那么 React 就无法知道上一次渲染时的数据和函数与这一次渲染时的数据和函数之间应该如何映射。简单来说就是下一次更新不知道上一次的状态，会导致渲染错误等问题。

## Diff 算法的区别

Vue2 的 Diff 算法主要有两个阶段：虚拟 DOM 的创建和新旧节点的对比。创建新的虚拟 DOM，首先，在数据更新时，Vue2 会通过计算生成新的 VNode。这些新生成的 VNode 会与旧的 VNode 进行比较，然后检测出两者之间的变化。新旧节点的对比（同层比较，如果节点相同继续比对子节点，深度优先），然后，进行新旧 VNode 之间的对比。Vue2 会逐层比较 VNode 的差异，并尽可能地复用已有的 VNode。在 Dom 节点复用时，Vue2 通过检查关键属性来确定 VNode 是否可复用。例如，如果新旧节点的标签名不同，那么该节点肯定不能复用；如果标签名相同但是 key 属性值不相同，则该节点也不能复用；如果标签名和 key 属性值都相同，那么这个节点可以复用，并且它的子节点会再次通过递归比较来进行更新。在叶节点比较时，Vue2 使用双端指针（start 和 end）来指向新旧节点的头和尾，并且判断它们是否相等。如果相等，则将指针向下移动（会使用 splice 进行数组操作）；如果不相等，则通过遍历过程来寻找与之匹配的节点，并进行移动、更新或删除操作，这个操作会根据头头，尾尾，头尾和尾头（不行再遍历）等几种情况进行优化，以减少不必要的计算量。这样能够提高算法的运行效率，使得在大多数情况下，算法都能够快速地完成节点的更新。

Vue3 是采用 Map 数据结构以及动静结合的方式，在编译阶段（模版解析）提前标记静态节点（静态标记优化），Diff 过程中直接跳过有静态标记的节点，并且子节点对比会使用一个 source 数组来记录节点位置及最长递增子序列算法优化了对比流程，快速 Diff，需要处理的边际条件会更少

React 是递归同层比较，标识差异点保存到 Diff 队列保存，得到 patch 树，再统一操作批量更新 DOM。Diff 总共就是移动、删除、增加三个操作，如果结构发生改变就直接卸载重新创建，如果没有则将节点在新集合中的位置和老集合中的 lastIndex 进行比较是否需要移动，如果遍历过程中发现新集合没有，但老集合有就删除

## Vue3 响应式的优化

Vue2 是使用 Object.defineProperty 递归给每一个 key 设置 getter 和 setter，render 执行的时候触发 getter，在 getter 里共同 Dep.addSub 通知 watcher 依赖收集，更新的时候触发 setter，通过 Dep.notify 去通知 watcher 更新页面

在 Vue3 的响应式原理中，使用 Proxy 对象懒监听对象的变化（运行才递归，用到才代理）。在使用 reactive 创建响应式对象时，会为该对象创建一个依赖收集器。当 effect 函数执行时，会创建一个 activeEffect 实例，用于在运行时动态记录依赖。然后执行传入的函数并在执行期间收集对象的所有依赖，包括 Getter 函数访问的所有 reactive 对象。这些依赖将被保存到一个依赖收集器中，使用了一个 weakMap 嵌套一个 set 的结构来存储依赖信息。

在 reactive 对象被修改时，会触发响应式系统的 trigger 机制。在触发过程中，会根据依赖收集器中存储的依赖来重新执行所有的 activeEffect 实例，并收集对应的依赖。如果某个依赖在 track 中已经收集了多次，会使用一个 Set 集合来去重。当所有的 effect 函数都被执行完毕时，会清空依赖收集器，以便下一次重新收集依赖。

为了提高效率，Vue3 使用了一些技巧来优化响应式系统的性能。例如，使用 Map 来存储响应式对象，这样可以在对象被删除时自动清理所有相关的依赖。在第一次收集依赖时，Vue3 会尝试使用 Reflect.ownKeys 来捕获对象的所有 keys，以避免 Proxy 陷入一个不断递归的循环。同时，Vue3 还通过在 trigger 中做一些特殊处理来避免在修改对象时执行过多的 effect 函数。所有这些优化手段的目的都是为了让 Vue3 的响应式系统更加高效和稳定。

```js
const state = reactive({ name: 'imber' }) //proxy监听对象变化

effect(() => {
  app.innerHTML = state.name
}) //执行effect函数

setTimeout(() => {
  state.name = 'ding'
}, 1000) //自动更新页面
```

## React18 的并发模式

Concurrent Mode 的引入，带来了以下几个方面的优势：

1. 提升应用的性能
   并发模式将一次渲染任务分解成多个小块，并通过 React 中的调度器（Scheduler）来优化执行顺序和时间，从而降低了单次渲染所需的计算资源和时间，提高了应用程序的性能。
2. 提高应用的可响应性
   并发模式可以在渲染过程中及时响应用户的输入和请求，避免出现 UI 卡顿或者无响应的情况，从而提高了应用程序的可响应性。
3. 改善用户体验
   并发模式优化了数据的加载和显示方式，使得用户可以更快地看到页面并开始交互，提高了整个应用的用户体验。
4. 如何使用 Concurrent Mode？React 官方从是否开启并发更新变化是否使用并发特性，React18 默认支持并发更新，也就是 ReactDOM.createRoot（之前还有 Legacy/Blocking 模式分别对应 render/createBlockingRoot）,然后使用 useDeferredValue 和 useTransition 去并发更新

## React 事件机制

#### 两个好处

1. 一个是通过自己生成合成事件，不依赖原生事件，可以实现跨平台能力

2. 一个是事件池复用事件，不用销毁重建，减少性能开销

#### 原理

基于自己实现的一套事件机制（合成事件系统），事件会被封装成合成事件对象（通过映射表映射原生事件），然后会模拟冒泡和捕获阶段（其实就是一个数组，用 unshift 把捕获到事件放最前面，冒泡则 push 放最后，更新的时候遍历执行），17 之前绑定在 document 上，17 开始绑定到 container 上（好像是为了微应用和并发更新而改的）

#### 扩展

因为不是真正的事件处理函数，所以 return false 会失效，而原生的 stopPropagation 和 preventDefault 是 react 重写的所以会生效

## React Fiber

#### 历史原因（产生原因）

因为 GUI 线程和 JS 线程互斥，老版本 React 遇到组件更新耗时的时候，一次大量的递归同步更新会因为占用 JS 线程，导致浏览器没有时间渲染造成页面卡顿

#### 好处（解决的问题）

fiber 架构有时间分片，中断任务，异步更新特性，解决一次性递归更新过多内容导致页面卡顿问题，主要是通过调度器 scheduler

## React Fiber 原理一：时间分片

React 时间分片（Time-slicing）是一种技术，它允许 React 在渲染页面时将大型渲染任务拆分为多个小任务（也就是每个工作单元就是一个组件就是一个 fiber 可以保存状态/副作用/expirationTime 等），并在它们之间进行切换，以保证页面的响应性能。

React 中时间分片的实现方式是使用 requestIdleCallback API，该 API 是浏览器提供的空闲回调 API，它可以注册回调函数，在浏览器空闲时间执行该函数，以完成一些较为耗时的任务。

拓展/加分：老版本因为 setTimeout 会延迟 4ms，会用 messageChannel 去模拟 RIC

## React Fiber 原理二：优先级调度

React 使用 fiber 架构来实现调度更新，每个 fiber 节点都保存了当前任务的优先级、任务类型等信息，并且根据优先级和任务类型动态调整执行顺序，以达到更好的用户体验。 利用“优先级”的概念（requestIdleCallback(callback,{timeout}设置的)）来确定 Reconciliation 及是否需要更新。优先级是一个整数，并且具有以下几个级别（从最高到最低）：

Immediate（优先级：1）：表示需要立即执行（例如用户的交互等），不可被打断（不可被优先级更低的任务打断）。

UserBlocking（优先级：2~3）：可以稍微等待的用户阻塞操作，例如输入，点击等交互直接的操作，需要反应及时。

Normal（优先级：4~5）：React 默认的优先级，任意可以稍稍延迟一下的任务，例如异步数据加载和渲染等。

Low（优先级：6~7）：较为不重要或是耗时的任务，例如图片懒加载、界面上一些轻微的动画（如滚动效果）等。

React 通过将任务分成不同的优先级，从而在执行更新操作时选择适当的任务优先级。这样一来，比较紧急的任务就能获得更高优先级的处理，而不会让这些任务因为其他任务的阻塞而变得不够及时，从而保证应用程序的响应速度和用户体验。

## React Fiber 原理三，异步可打断更新

React Fiber 的另一个特性是支持可中断和恢复，即当 React 开始进行一次更新时，如果用户在此期间对界面进行了操作，则 React 可以中断当前更新，转而处理用户操作，等用户操作执行完成后再恢复之前的更新操作，这样可以更好地响应用户交互。

React Fiber 是一种重新设计的算法，将 React 的渲染过程分成了两个阶段：Reconciliation Phase（协调阶段）和 Commit Phase（提交阶段）。将整个渲染过程拆分成更小的单元，通过可中断的方式在任务优先级之间交替执行，使 React 可以更好地处理大型和复杂的应用程序，并更灵活地调整其渲染处理速度和资源占用。

## 时间分片和优先级的不同

时间分片和优先级在 React 中都是通过 requestCallback 机制来实现的，但是具体的应用方式和用途是不同的。

在时间分片中，requestCallback 用来注册一个将在下一个空闲时间段执行的回调函数，通过控制回调函数的执行来实现任务的时间分片。Scheduler 在更新任务队列时会调用 requestCallback，并将任务按照优先级放入不同的链表中，然后调度内核去执行这个请求并异步执行回调函数。

在优先级中，利用了 requestIdleCallback 机制。它能够在系统空闲的时候异步地执行任务。这个 API 通常会在时间分片机制之后触发，以便给更重要的任务更高的优先级。Scheduler 会根据任务的优先级和任务队列中的任务情况，调用 requestIdleCallback 来调度任务的执行。当浏览器处于空闲状态时，requestIdleCallback 会异步地执行排队的任务，使其在空闲时间段内优先执行。

## 调度流程

GUI 线程和 JS 线程互斥，一次大量的递归更新会造成卡顿，占用 js 线程，导致浏览器没时间做渲染，解决方案：交给浏览器自己控制，有绘制执行绘制，有空闲执行更新，scheduler 就是具体的实现方式

对比 Vue：vue 能精确依赖收集找到更新范围，以组件颗粒度更新，react 不确定范围需要从根节点 diff 更新（无脑更新一把梭），这里可以得出两个框架优化的方向，一个是细分组件，一个是浅比较组件减少不必要渲染

## 调和流程

## React 组件批量更新

## setState 更新流程

## React 组件渲染流程

## commit 和 render 两个阶段

## React Server Component

## Redux
