> https://juejin.cn/post/7124955707723481125 这是之前的一部分理解，又写了一段时间 react 和 nextjs，再来补充一部分

## Hook 的不同

Hook 在 React 函数组件中用于添加状态和副作用。它们可以使函数组件像类组件一样具有状态和副作用，但是在使用它们时，需要注意一些限制。

首先，Hook 必须在函数组件的顶层调用，这意味着它们不能在循环、条件判断或嵌套函数中使用，因为 React 需要确保每次渲染时，Hook 的顺序不会改变。由于 React 可能会多次调用组件函数，因此使用 Hook 的顺序必须始终保持一致，以确保数据和函数之间的关系正确。

当 React 需要重新渲染组件时，它会调用函数组件，计算出组件的新 Props 和 State，然后重新运行组件函数来生成组件的 UI 元素，最终展现在界面上。如果 Hook 的顺序在不同的渲染过程中发生了变化，那么 React 就无法知道上一次渲染时的数据和函数与这一次渲染时的数据和函数之间应该如何映射。简单来说就是下一次更新不知道上一次的状态，会导致渲染错误等问题。

## Diff 算法的区别

Vue2 的 Diff 算法主要有两个阶段：虚拟 DOM 的创建和新旧节点的对比。创建新的虚拟 DOM，首先，在数据更新时，Vue2 会通过计算生成新的 VNode。这些新生成的 VNode 会与旧的 VNode 进行比较，然后检测出两者之间的变化。新旧节点的对比（同层比较，如果节点相同继续比对子节点，深度优先），然后，进行新旧 VNode 之间的对比。Vue2 会逐层比较 VNode 的差异，并尽可能地复用已有的 VNode。在 Dom 节点复用时，Vue2 通过检查关键属性来确定 VNode 是否可复用。例如，如果新旧节点的标签名不同，那么该节点肯定不能复用；如果标签名相同但是 key 属性值不相同，则该节点也不能复用；如果标签名和 key 属性值都相同，那么这个节点可以复用，并且它的子节点会再次通过递归比较来进行更新。在叶节点比较时，Vue2 使用双端指针（start 和 end）来指向新旧节点的头和尾，并且判断它们是否相等。如果相等，则将指针向下移动（会使用 splice 进行数组操作）；如果不相等，则通过遍历过程来寻找与之匹配的节点，并进行移动、更新或删除操作，这个操作会根据头头，尾尾，头尾和尾头（不行再遍历）等几种情况进行优化，以减少不必要的计算量。这样能够提高算法的运行效率，使得在大多数情况下，算法都能够快速地完成节点的更新。

Vue3 是采用 Map 数据结构以及动静结合的方式，在编译阶段（模版解析）提前标记静态节点（静态标记优化），Diff 过程中直接跳过有静态标记的节点，并且子节点对比会使用一个 source 数组来记录节点位置及最长递增子序列算法优化了对比流程，快速 Diff，需要处理的边际条件会更少

React 是递归同层比较，标识差异点保存到 Diff 队列保存，得到 patch 树，再统一操作批量更新 DOM。Diff 总共就是移动、删除、增加三个操作，如果结构发生改变就直接卸载重新创建，如果没有则将节点在新集合中的位置和老集合中的 lastIndex 进行比较是否需要移动，如果遍历过程中发现新集合没有，但老集合有就删除

## Vue3 响应式的优化

Vue2 是使用 Object.defineProperty 递归给每一个 key 设置 getter 和 setter，render 执行的时候触发 getter，在 getter 里共同 Dep.addSub 通知 watcher 依赖收集，更新的时候触发 setter，通过 Dep.notify 去通知 watcher 更新页面

在 Vue3 的响应式原理中，使用 Proxy 对象懒监听对象的变化（运行才递归，用到才代理）。在使用 reactive 创建响应式对象时，会为该对象创建一个依赖收集器。当 effect 函数执行时，会创建一个 activeEffect 实例，用于在运行时动态记录依赖。然后执行传入的函数并在执行期间收集对象的所有依赖，包括 Getter 函数访问的所有 reactive 对象。这些依赖将被保存到一个依赖收集器中，使用了一个 weakMap 嵌套一个 set 的结构来存储依赖信息。

在 reactive 对象被修改时，会触发响应式系统的 trigger 机制。在触发过程中，会根据依赖收集器中存储的依赖来重新执行所有的 activeEffect 实例，并收集对应的依赖。如果某个依赖在 track 中已经收集了多次，会使用一个 Set 集合来去重。当所有的 effect 函数都被执行完毕时，会清空依赖收集器，以便下一次重新收集依赖。

为了提高效率，Vue3 使用了一些技巧来优化响应式系统的性能。例如，使用 Map 来存储响应式对象，这样可以在对象被删除时自动清理所有相关的依赖。在第一次收集依赖时，Vue3 会尝试使用 Reflect.ownKeys 来捕获对象的所有 keys，以避免 Proxy 陷入一个不断递归的循环。同时，Vue3 还通过在 trigger 中做一些特殊处理来避免在修改对象时执行过多的 effect 函数。所有这些优化手段的目的都是为了让 Vue3 的响应式系统更加高效和稳定。

```js
const state = reactive({ name: 'imber' }) //proxy监听对象变化

effect(() => {
  app.innerHTML = state.name
}) //执行effect函数

setTimeout(() => {
  state.name = 'ding'
}, 1000) //自动更新页面
```

## React18 的并发模式

Concurrent Mode 的引入，带来了以下几个方面的优势：

1. 提升应用的性能
   并发模式将一次渲染任务分解成多个小块，并通过 React 中的调度器（Scheduler）来优化执行顺序和时间，从而降低了单次渲染所需的计算资源和时间，提高了应用程序的性能。
2. 提高应用的可响应性
   并发模式可以在渲染过程中及时响应用户的输入和请求，避免出现 UI 卡顿或者无响应的情况，从而提高了应用程序的可响应性。
3. 改善用户体验
   并发模式优化了数据的加载和显示方式，使得用户可以更快地看到页面并开始交互，提高了整个应用的用户体验。
   如何使用 Concurrent Mode？
   在 React 18 中，启用 Concurrent Mode 是非常简单的，只需要在 ReactDOM.render 函数中添加一个 mode 参数即可。例如：
   javascript 复制代码 ReactDOM.render(<App />, document.getElementById('root'), { mode: 'concurrent' })

并发模式可能会导致数据的不稳定性，因此需要使用 React 的新 Hook 函数和 Suspense 组件来处理数据加载和显示的问题。例如，使用 useTransition 和 Suspense 组件来优化数据的加载和显示：

```js
const [startTransition, isPending] = useTransition({ timeoutMs: 1000 })

function handleClick() {
  startTransition(() => {
    // 在这里更新状态
  })
}

return (
  <Suspense fallback={<Spinner />}>
    {isPending ? <Spinner /> : <DataComponent />}
  </Suspense>
)
```

并发模式目前仍处于实验阶段，并且可能会对现有应用程序产生一些影响。因此，在使用并发模式时，我们需要注意以下几点：

1.并发模式可能会导致组件渲染的顺序发生变化，从而引起一些不稳定的问题。因此，需要仔细检查代码中是否存在依赖组件渲染顺序的逻辑，并使用 React 提供的新的生命周期函数或 Hook 函数来解决这些问题。

2.并发模式可能会导致数据的不稳定性，从而引起数据加载和显示的问题。因此，需要使用 Suspense 组件和 useTransition Hook 来优化数据的加载和显示，确保数据的稳定性。

3.并发模式目前还处于实验阶段，并且存在一些兼容性问题。在使用并发模式时，需要特别注意在不同浏览器和设备上的表现，以确保应用程序能够正常运行。

## React Server Component
