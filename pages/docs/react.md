> https://juejin.cn/post/7124955707723481125 这是之前的一部分理解，又写了一段时间 react 和 nextjs，再来补充一部分

## Hook 的不同

Hook 在 React 函数组件中用于添加状态和副作用。它们可以使函数组件像类组件一样具有状态和副作用，但是在使用它们时，需要注意一些限制。

首先，Hook 必须在函数组件的顶层调用，这意味着它们不能在循环、条件判断或嵌套函数中使用，因为 React 需要确保每次渲染时，Hook 的顺序不会改变。由于 React 可能会多次调用组件函数，因此使用 Hook 的顺序必须始终保持一致，以确保数据和函数之间的关系正确。

当 React 需要重新渲染组件时，它会调用函数组件，计算出组件的新 Props 和 State，然后重新运行组件函数来生成组件的 UI 元素，最终展现在界面上。如果 Hook 的顺序在不同的渲染过程中发生了变化，那么 React 就无法知道上一次渲染时的数据和函数与这一次渲染时的数据和函数之间应该如何映射。简单来说就是下一次更新不知道上一次的状态，会导致渲染错误等问题。

## Diff 算法的区别

Vue2 是同层比较新老 vnode，新的不存在老的存在就删除，新的存在老的不存在就创建，子节点采用双指针头对尾两端对比的方式，全量 diff，然后移动节点时通过 splice 进行数组操作

Vue3 是采用 Map 数据结构以及动静结合的方式，在编译阶段提前标记静态节点，Diff 过程中直接跳过有静态标记的节点，并且子节点对比会使用一个 source 数组来记录节点位置及最长递增子序列算法优化了对比流程，快速 Diff，需要处理的边际条件会更少

React 是递归同层比较，标识差异点保存到 Diff 队列保存，得到 patch 树，再统一操作批量更新 DOM。Diff 总共就是移动、删除、增加三个操作，如果结构发生改变就直接卸载重新创建，如果没有则将节点在新集合中的位置和老集合中的 lastIndex 进行比较是否需要移动，如果遍历过程中发现新集合没有，但老集合有就删除

## Vue3 响应式的优化

Vue2 是使用 Object.defineProperty 递归给每一个 key 设置 getter 和 setter，render 执行的时候触发 getter，在 getter 里共同 Dep.addSub 通知 watcher 依赖收集，更新的时候触发 setter，通过 Dep.notify 去通知 watcher 更新页面

在 Vue3 的响应式原理中，使用 Proxy 对象懒监听对象的变化（运行才递归，用到才代理）。在使用 reactive 创建响应式对象时，会为该对象创建一个依赖收集器。当 effect 函数执行时，会创建一个 activeEffect 实例，用于在运行时动态记录依赖。然后执行传入的函数并在执行期间收集对象的所有依赖，包括 Getter 函数访问的所有 reactive 对象。这些依赖将被保存到一个依赖收集器中，使用了一个 weakMap 嵌套一个 set 的结构来存储依赖信息。

在 reactive 对象被修改时，会触发响应式系统的 trigger 机制。在触发过程中，会根据依赖收集器中存储的依赖来重新执行所有的 activeEffect 实例，并收集对应的依赖。如果某个依赖在 track 中已经收集了多次，会使用一个 Set 集合来去重。当所有的 effect 函数都被执行完毕时，会清空依赖收集器，以便下一次重新收集依赖。

为了提高效率，Vue3 使用了一些技巧来优化响应式系统的性能。例如，使用 Map 来存储响应式对象，这样可以在对象被删除时自动清理所有相关的依赖。在第一次收集依赖时，Vue3 会尝试使用 Reflect.ownKeys 来捕获对象的所有 keys，以避免 Proxy 陷入一个不断递归的循环。同时，Vue3 还通过在 trigger 中做一些特殊处理来避免在修改对象时执行过多的 effect 函数。所有这些优化手段的目的都是为了让 Vue3 的响应式系统更加高效和稳定。

```js
const state = reactive({ name: 'imber' }) //proxy监听对象变化

effect(() => {
  app.innerHTML = state.name
}) //执行effect函数

setTimeout(() => {
  state.name = 'ding'
}, 1000) //自动更新页面
```

## React18 的并发模式

https://juejin.cn/post/7223653429356773434

## React Server Component
